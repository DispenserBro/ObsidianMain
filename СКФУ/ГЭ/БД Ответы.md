### Базы данных

1. **Основные определения реляционной модели данных:** Реляционная модель данных представляет данные в виде таблиц (отношений), где строки являются записями (кортежами), а столбцы – атрибутами. Основные элементы реляционной модели включают домены (допустимые значения атрибутов), отношения (таблицы) и ограничения целостности. Основным свойством реляционной модели является независимость данных, что позволяет изменять физическое хранилище без влияния на логическое представление. Каждое отношение имеет уникальное имя, а строки идентифицируются ключами. Пример: таблица "Сотрудники" с атрибутами "ID", "Имя", "Должность" представляет отношение, где каждая строка соответствует отдельному сотруднику.
2. **Понятие "отношения":** Отношение – это математическое представление таблицы, состоящее из упорядоченного набора строк и столбцов. Каждый столбец имеет имя и определённый домен, а каждая строка содержит уникальный набор данных. Отношения обладают рядом свойств: строки не упорядочены, значения атомарны, а атрибуты принимают только значения своего домена. Уникальность строк обеспечивается первичным ключом. Пример: отношение "Книги" с атрибутами "Название", "Автор", "Год издания" может содержать строки, где каждая запись представляет конкретную книгу.
3. **Реляционные ключи:** Ключ – это атрибут или их комбинация, которая уникально идентифицирует строку в таблице. Основные типы ключей: первичный, внешний и альтернативный. Первичный ключ (Primary Key) обеспечивает уникальность записей в таблице. Внешний ключ (Foreign Key) связывает данные между таблицами. Альтернативные ключи – это возможные кандидаты на роль первичного ключа. Пример: в таблице "Сотрудники" атрибут "ID" может быть первичным ключом, а атрибут "Департамент" – внешним ключом, ссылающимся на таблицу "Департаменты".
4. **Реляционная целостность:** Реляционная целостность – это набор правил, обеспечивающих корректность данных в базе. Основные типы: сущностная целостность (значения первичного ключа не могут быть пустыми), ссылочная целостность (внешние ключи должны ссылаться на существующие записи) и доменная целостность (значения атрибутов должны соответствовать своему домену). Эти правила предотвращают появление несогласованных или некорректных данных. Например, удаление записи из родительской таблицы требует либо удаления связанных данных, либо обновления ссылок. Пример: в таблице "Заказы" внешний ключ "Код клиента" должен ссылаться на существующую запись в таблице "Клиенты".
5. **Реляционная алгебра: выборка, проекция, декартово произведение, присвоение, переименование. Примеры:** Реляционная алгебра – это формальный язык для работы с отношениями. Основные операции: выборка (σ) фильтрует строки, проекция (π) выбирает столбцы, декартово произведение (×) соединяет все строки двух таблиц, присвоение сохраняет результат в новой таблице, а переименование (ρ) изменяет имена атрибутов. Выборка используется для извлечения данных, соответствующих условиям, например: σВозраст>30(Сотрудники). Проекция позволяет выбрать только нужные атрибуты: πИмя,Должность(Сотрудники). Пример: в таблице "Продукты" операция σЦена<100 выбирает товары дешевле 100 единиц.
6. **Реляционная алгебра: объединение, разность, пересечение, деление. Примеры:** Операции объединения (∪), разности (−), пересечения (∩) и деления (÷) применяются для манипулирования отношениями. Объединение позволяет создать новое отношение, содержащее строки из обоих исходных отношений. Разность возвращает строки, которые присутствуют в одном отношении, но отсутствуют в другом. Пересечение создаёт отношение, содержащее только общие строки. Деление используется для извлечения тех строк, которые связаны со всеми значениями атрибута из второго отношения. Пример: если есть таблицы "Студенты" и "Курсы", операция деления покажет студентов, которые посещают все указанные курсы.
7. **Реляционная алгебра: соединение. Примеры:** Соединение (⋈) – это операция, которая объединяет две таблицы на основе общего атрибута. Соединение может быть внутренним (только совпадающие строки), внешним (включая строки без совпадений) и естественным (автоматически соединяет по общим атрибутам). Например, операция соединения таблиц "Сотрудники" и "Департаменты" по атрибуту "ID департамента" создаёт новую таблицу с информацией о сотрудниках и их департаментах. Пример: внутреннее соединение – σСотрудники.ID_департамента=Департаменты.ID(Сотрудники ⋈ Департаменты).
8. **Реляционное исчисление кортежей. Кванторы существования и общности. Примеры:** Реляционное исчисление – это декларативный способ описания запросов. Исчисление кортежей основывается на кванторах существования (∃) и общности (∀). Квантор существования используется для поиска строк, удовлетворяющих условию, а общности – для проверки, что все строки соответствуют условию. Пример: запрос "Найти всех сотрудников старше 30 лет" записывается как ∃x (Сотрудники(x) ∧ x.возраст > 30).
9. **Реляционное исчисление кортежей. Выражения и формулы. Примеры:** Реляционное исчисление кортежей позволяет задавать сложные условия с помощью логических операторов (И, ИЛИ, НЕ). Формулы включают атрибуты, операторы сравнения и значения. Пример: запрос "Найти всех сотрудников из отдела продаж" записывается как {x | Сотрудники(x) ∧ x.отдел = 'Продажи'}. Такие выражения позволяют декларативно описывать выборку данных.
10. **Запись операторов SQL:** SQL (Structured Query Language) – это язык работы с реляционными базами данных. Основные операторы включают SELECT (выборка), INSERT (добавление), UPDATE (обновление) и DELETE (удаление). Запросы SQL состоят из ключевых слов, определяющих действия с данными, и условий. Например, SELECT позволяет извлечь данные из таблиц с фильтрацией и сортировкой. Пример: "SELECT * FROM Сотрудники WHERE возраст > 30" выбирает всех сотрудников старше 30 лет.
11. **Оператор Select. Примеры простых запросов:** Оператор SELECT используется для извлечения данных из таблиц базы данных. Простые запросы могут включать выборку всех данных или определённых столбцов. Например, запрос "SELECT * FROM Сотрудники" извлекает все строки и столбцы таблицы "Сотрудники". Дополнительно можно выбирать конкретные столбцы: "SELECT Имя, Должность FROM Сотрудники". Также возможно добавление простых условий фильтрации, чтобы ограничить выборку данных. Пример: "SELECT Имя FROM Сотрудники WHERE Возраст > 30" возвращает имена сотрудников старше 30 лет.
12. **Запросы с фильтрацией. Примеры:** Фильтрация данных осуществляется с использованием ключевого слова WHERE, которое добавляет условия к запросу. Условия могут включать сравнение (>, <, =), логические операторы (AND, OR) и проверку наличия значений (IS NULL). Пример: "SELECT \* FROM Продукты WHERE Цена < 100 AND Наличие > 0" возвращает все доступные товары с ценой менее 100 единиц. Также можно использовать сложные выражения, например: "SELECT Имя FROM Сотрудники WHERE Отдел = 'IT' OR Должность = 'Менеджер'".
13. **Сортировка результатов запросов. Примеры:** Сортировка выполняется с использованием ключевого слова ORDER BY, которое может упорядочивать данные по возрастанию (ASC) или убыванию (DESC). Например, запрос "SELECT * FROM Сотрудники ORDER BY Имя ASC" отсортирует сотрудников в алфавитном порядке. Можно сортировать по нескольким столбцам: "SELECT \* FROM Продукты ORDER BY Категория DESC, Цена ASC". Такой запрос сначала упорядочит данные по категории, а внутри категории – по цене. Пример: "SELECT Имя, Должность FROM Сотрудники ORDER BY Должность DESC" сортирует сотрудников по убыванию должности.
14. **Агрегирование данных. Примеры:** Агрегатные функции, такие как COUNT, SUM, AVG, MAX и MIN, используются для подсчёта и анализа данных. Например, "SELECT COUNT(\*) FROM Заказы" возвращает общее количество заказов. Функция SUM суммирует значения столбца: "SELECT SUM(Сумма) FROM Заказы WHERE Клиент = 'Иванов'". AVG рассчитывает среднее значение: "SELECT AVG(Цена) FROM Продукты". MAX и MIN находят максимальное и минимальное значения. Пример: "SELECT MAX(Зарплата) FROM Сотрудники WHERE Отдел = 'IT'" возвращает максимальную зарплату в отделе IT.
15. **Группировка результатов. Примеры:** Группировка осуществляется с помощью ключевого слова GROUP BY и позволяет объединить строки с одинаковыми значениями в определённом столбце. Например, запрос "SELECT Отдел, COUNT(\*) FROM Сотрудники GROUP BY Отдел" показывает количество сотрудников в каждом отделе. Дополнительно можно использовать агрегатные функции: "SELECT Категория, AVG(Цена) FROM Продукты GROUP BY Категория". Это вернёт среднюю цену по каждой категории. Пример: "SELECT Год, SUM(Продажи) FROM Продажи GROUP BY Год" отображает общие продажи за каждый год.
16. **Подзапросы. Примеры:** Подзапросы – это запросы, вложенные внутри другого SQL-запроса. Они могут использоваться в условиях фильтрации, выборе данных или вычислении агрегатных значений. Подзапросы бывают скалярными (возвращают одно значение) и табличными (возвращают несколько строк). Пример: "SELECT Имя FROM Сотрудники WHERE ID_Департамента = (SELECT ID FROM Департаменты WHERE Название = 'IT')". Этот запрос выбирает имена сотрудников, работающих в департаменте IT. Также подзапросы могут быть коррелированными, когда внутренний запрос зависит от внешнего: "SELECT Имя FROM Сотрудники s WHERE Зарплата > (SELECT AVG(Зарплата) FROM Сотрудники WHERE Департамент = s.Департамент)".
17. **Многотабличные запросы:** Многотабличные запросы объединяют данные из нескольких таблиц с использованием ключевых слов JOIN. Виды соединений включают INNER JOIN (внутреннее соединение), LEFT JOIN (левое соединение), RIGHT JOIN (правое соединение) и FULL JOIN (полное соединение). Пример: "SELECT Сотрудники.Имя, Департаменты.Название FROM Сотрудники INNER JOIN Департаменты ON Сотрудники.ID_Департамента = Департаменты.ID". Этот запрос возвращает имена сотрудников вместе с названиями их департаментов. Многотабличные запросы позволяют объединять данные и выполнять над ними операции, такие как сортировка, фильтрация или агрегирование.
18. **Ключевые слова EXISTS, NOT EXISTS:** Ключевые слова EXISTS и NOT EXISTS используются для проверки наличия строк в подзапросах. EXISTS возвращает TRUE, если подзапрос возвращает хотя бы одну строку, а NOT EXISTS – если ни одной строки нет. Пример: "SELECT Имя FROM Сотрудники WHERE EXISTS (SELECT 1 FROM Проекты WHERE Сотрудники.ID = Проекты.ID_Сотрудника)". Этот запрос возвращает имена сотрудников, которые участвуют в проектах. NOT EXISTS может использоваться для нахождения записей, не имеющих связей: "SELECT Имя FROM Сотрудники WHERE NOT EXISTS (SELECT 1 FROM Проекты WHERE Сотрудники.ID = Проекты.ID_Сотрудника)".
19. **Комбинирование результатов запросов: UNION, INTERSECT, EXCEPT:** Операторы UNION, INTERSECT и EXCEPT позволяют объединять результаты нескольких запросов. UNION объединяет результаты двух запросов, удаляя дубликаты (UNION ALL сохраняет их). INTERSECT возвращает только общие строки, а EXCEPT – строки, которые есть в первом запросе, но отсутствуют во втором. Пример: "SELECT Имя FROM Сотрудники UNION SELECT Имя FROM Клиенты" возвращает объединённый список имён сотрудников и клиентов. "SELECT Имя FROM Сотрудники INTERSECT SELECT Имя FROM Клиенты" – только те имена, которые есть в обеих таблицах.
20. **Команды изменения данных: INSERT, UPDATE, DELETE:** Команды изменения данных используются для вставки, обновления и удаления записей. INSERT добавляет новые строки: "INSERT INTO Сотрудники (Имя, Должность) VALUES ('Иван', 'Менеджер')". UPDATE изменяет существующие записи: "UPDATE Сотрудники SET Зарплата = Зарплата * 1.1 WHERE Должность = 'Менеджер'". DELETE удаляет записи: "DELETE FROM Сотрудники WHERE Зарплата < 50000". Эти команды позволяют изменять данные в таблицах, поддерживая их актуальность и корректность.
21. **DDL-операторы: CREATE TABLE, ALTER TABLE, DROP TABLE:** DDL (Data Definition Language) – это часть SQL, используемая для определения структуры базы данных. Команда CREATE TABLE создаёт новую таблицу: "CREATE TABLE Сотрудники (ID INT PRIMARY KEY, Имя VARCHAR(50), Зарплата DECIMAL(10, 2))". ALTER TABLE изменяет структуру существующей таблицы, например: "ALTER TABLE Сотрудники ADD Дата_Рождения DATE". DROP TABLE удаляет таблицу из базы данных: "DROP TABLE Сотрудники". Эти команды позволяют проектировать и изменять схему базы данных.
22. **Типы данных MS SQL Server:** MS SQL Server поддерживает множество типов данных, включая числовые (INT, DECIMAL), строковые (VARCHAR, NVARCHAR), даты и времени (DATE, DATETIME), а также бинарные (BINARY, VARBINARY). Строковые данные могут быть фиксированной длины (CHAR) или переменной (VARCHAR). Типы данных позволяют определить, какие значения допустимы для каждого столбца. Пример: столбец с типом INT может содержать только целые числа, а VARCHAR(50) – строки длиной до 50 символов.
23. **Модель "Сущность-связь". Типы сущностей, типы связей:** Модель "Сущность-связь" (ER-модель) описывает данные в виде сущностей и связей между ними. Сущности представляют объекты реального мира, такие как "Сотрудники" или "Проекты". Связи описывают взаимоотношения между сущностями, например "Сотрудники работают в Департаментах". Типы сущностей: сильные (с независимым существованием) и слабые (зависят от других сущностей). Типы связей включают один-к-одному, один-ко-многим и многие-ко-многим.
24. **Модель "Сущность-связь". Атрибуты:** Атрибуты – это характеристики, описывающие сущности. Например, у сущности "Сотрудник" могут быть атрибуты "Имя", "Возраст", "Зарплата". Атрибуты могут быть простыми (атомарными), составными (например, адрес) или многозначными (список телефонов). Пример: сущность "Проект" может иметь атрибуты "Название", "Дата начала" и "Бюджет".
25. **Модель "Сущность-связь". Сущности сильного и слабого типов. Структурные ограничения:** Сильные сущности имеют первичный ключ, который уникально идентифицирует каждую запись (например, "Сотрудники" с ключом "ID"). Слабые сущности зависят от сильных и идентифицируются с использованием внешнего ключа, например, "Детали заказа". Структурные ограничения определяют допустимые количества связей между сущностями. Например, один-ко-многим (один сотрудник может быть в одном департаменте, но департамент может включать многих сотрудников).
26. **Модель "Сущность-связь". Проблемы ER-моделирования:** Проблемы ER-моделирования включают сложности в проектировании сложных связей, представлении иерархий и учёте ограничений целостности. Часто возникают трудности при преобразовании ER-модели в реляционную схему, особенно если связи имеют сложную структуру. Ещё одной проблемой является возможность избыточности данных в моделях, что может привести к аномалиям при обработке данных. Например, неэффективное представление связей "многие-ко-многим" может усложнить управление данными. Решение таких проблем включает использование нормализации и оптимизации схемы модели.
27. **Избыточность данных и аномалии обработки данных:** Избыточность данных возникает, когда одно и то же значение хранится в нескольких местах, что приводит к увеличению объёма базы данных и возможным ошибкам. Аномалии обработки данных делятся на три типа: вставки, обновления и удаления. Аномалия вставки возникает, когда невозможно добавить запись из-за отсутствия связанных данных. Аномалия обновления связана с необходимостью изменять одно и то же значение в нескольких местах. Аномалия удаления происходит, когда удаление записи приводит к утрате важных данных. Пример: при хранении данных о студентах и их курсах в одной таблице изменения курса требуют обновления всех записей, где он упоминается.
28. **Функциональные зависимости. Аксиомы Армстронга:** Функциональная зависимость – это связь между атрибутами, при которой значение одного атрибута однозначно определяет значение другого. Например, "ID сотрудника" определяет "Имя" и "Должность". Аксиомы Армстронга включают правила рефлексивности, транзитивности и псевдотранзитивности, которые используются для вывода новых зависимостей из существующих. Они помогают определить минимальный набор зависимостей, необходимых для проектирования базы данных. Пример: если A → B и B → C, то A → C (транзитивность).
29. **Ненормализованные отношения. Первая нормальная форма. Процесс flattening:** Ненормализованные отношения содержат избыточные или повторяющиеся данные, что может приводить к аномалиям. Первая нормальная форма (1НФ) устраняет многозначные атрибуты, представляя данные в виде таблицы с атомарными значениями. Процесс flattening включает преобразование сложных структур данных (например, списков или массивов) в строки таблицы. Это упрощает управление данными, но может увеличить объём таблицы. Пример: преобразование атрибута "Телефоны" со значениями "123, 456" в две отдельные строки таблицы.
30. **Вторая нормальная форма. Теорема Хеза:** Вторая нормальная форма (2НФ) устраняет частичные зависимости между атрибутами. Для этого каждый неключевой атрибут должен зависеть от всего первичного ключа, а не от его части. Теорема Хеза гласит, что отношение находится во 2НФ, если оно находится в 1НФ и все его неключевые атрибуты зависят от всего ключа. Это позволяет устранить избыточность и снизить вероятность аномалий обработки данных. Пример: в таблице "Заказы" с атрибутами "Номер заказа", "Код клиента", "Имя клиента" переносим "Имя клиента" в отдельную таблицу, чтобы устранить зависимость только от "Кода клиента".
31. **Третья нормальная форма:** Третья нормальная форма (3НФ) устраняет транзитивные зависимости, когда неключевые атрибуты зависят друг от друга через промежуточный атрибут. Отношение находится в 3НФ, если оно уже в 2НФ и каждый неключевой атрибут зависит только от первичного ключа. Например, в таблице "Заказы" атрибут "Город клиента" зависит от "Кода клиента". Чтобы привести таблицу к 3НФ, "Город клиента" переносится в отдельную таблицу, связанную с "Кодом клиента".
32. **Нормальная форма Бойса-Кодда:** НФБК (BCNF) является усилением 3НФ и устраняет зависимости, которые могут оставаться в 3НФ, если первичный ключ состоит из нескольких атрибутов. Отношение находится в НФБК, если для любой функциональной зависимости левый атрибут является суперключом. Пример: в таблице "Занятия" с атрибутами "Преподаватель", "Предмет", "Аудитория" может быть зависимость "Преподаватель → Аудитория", что нарушает НФБК. Для исправления создаётся новая таблица "Преподаватели и аудитории".
33. **Четвёртая нормальная форма:** 4НФ устраняет многозначные зависимости, которые могут возникать, если один атрибут связан с несколькими наборами значений другого атрибута. Отношение находится в 4НФ, если оно находится в НФБК и не содержит таких зависимостей. Пример: таблица "Студенты" с атрибутами "Имя", "Курсы", "Клубы" содержит многозначную зависимость между "Курсами" и "Клубами". Для приведения в 4НФ данные разделяются на две таблицы: "Студенты и курсы" и "Студенты и клубы".
34. **Пятая нормальная форма:** 5НФ устраняет соединительные зависимости, которые возникают, если данные можно разделить на более мелкие таблицы, при этом теряется их первоначальная целостность. Таблица находится в 5НФ, если её можно разложить на несколько таблиц, и при этом все данные можно восстановить без потерь. Пример: таблица "Проекты" с атрибутами "Менеджер", "Проект", "Клиент" может содержать зависимости, которые требуют разделения на три таблицы: "Менеджеры и проекты", "Проекты и клиенты", "Менеджеры и клиенты".
35. **Методология проектирования БД:** Проектирование базы данных включает несколько этапов: анализ требований, создание концептуальной модели (например, ER-модели), преобразование модели в реляционную схему, нормализация и оптимизация. На этапе анализа требований выявляются сущности, атрибуты и связи между ними. Концептуальная модель уточняется и преобразуется в реляционную схему, которая проходит нормализацию для устранения избыточности. Последний этап – физическое проектирование, где определяются индексы, ограничения и структуры хранения данных. Пример: проектирование базы данных для интернет-магазина начинается с выявления сущностей "Клиенты", "Заказы", "Товары" и их связей, а затем нормализуется для минимизации избыточности.